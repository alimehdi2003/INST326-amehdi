AI Usage Journal
Abbas Mehdi
amehdi@terpmail.umd.edu
Section 0203
Week 1

The beginning week of the semester I used GEMENI AI to figure out what formatting mistakes I made in my print statements
that involved f strings and printing the numeric outputs of variables. I also needed to understand what syntax errors I made.
I asked GEMENI to help me understand python concepts that I found to be foreign and forgotten such as slicing as well understanding
the type() comamand. I was a bit stumped when it came to some of the exercise computations unsure why the output value wasn't rounded to two decimal places
debugging and asking me to show the correct format. I also found extracting specific parts of a string (prefix, section, cutter) using only .find()/.rfind() 
and slicing can be tricky. 

I usually prefer using Chat GPT but since GEMENI has already part of the jupyter file it more reliable to use rather paste code on Chat GPT

Week 2

I used GEMENI a lot for this week's exercises. I used Gemini a lot for this week’s exercises because I had difficulty distinguishing between working with entire lists and accessing individual elements inside loops. I also struggled with printing results inside loops when I really only needed to display the outcome. Another challenge was remembering to update the correct variable during comparisons, such as finding the longest title or the maximum value. At times, I forgot to handle the “not found” or default case when running searches, which caused incomplete solutions. My loop logic often became more complicated than necessary, making problems harder than they needed to be. I sometimes printed the wrong value, such as showing an index instead of the corresponding name. such as distinguishing between entire lists and single elements in loops (like when printing each book’s availability), printing results inside loops instead of only once at the end (as in counting checked-out books), updating the correct variable during comparisons (for example, finding the longest title or the most active borrower), handling “not found” cases in searches (like when a book was missing), simplifying loop logic (for instance, when merging two shelves), and printing the wrong values, such as indices instead of matching titles or authors.

Week 3

I was practicing some Python problems on my own and used ChatGPT when I got stuck. In one exercise, I had to work with strings by joining first and last names together and then filtering them based on the starting letters. I wrote the code and asked ChatGPT to check if it was correct, and it confirmed that using string concatenation, comparisons, and sorting was the right approach. In another exercise, I needed to handle lists that contained None values and replace those with the text “Not Yet Processed.” I wasn’t sure of the best way to do it, so ChatGPT walked me through a method where I separated the data and then merged it back while adding the text in place of the None values. This gave me the correct output and helped me better understand how to handle missing values in Python.

Regarding this week's exercises, I realized that I needed to pay closer attention to the structure of functions, especially remembering how to use def, write parameters correctly, and keep my indentation consistent. Sometimes I mixed up when to use variables inside a function versus passing them in, and I also forgot to return values, which meant my functions didn’t actually give anything back. I had to slow down to understand how return statements work and why they matter.

Another area where I needed practice was with conditionals and booleans. Checking availability, flipping between True and False, and setting up if and else branches sometimes felt confusing, but seeing working examples helped me figure out the patterns. I also learned how to use string methods like .strip(), .lower(), .upper(), and title() to clean up and compare text. This was especially useful when building functions that search for titles or match prefixes.

Working with lists was another challenge. I had to understand the difference between looping by index and looping directly over items, and it took practice to see when each approach was better.


Week 4:
For Week 4, I relied heavily on AI assistance to complete the exercises because they were difficult for me to solve on my own. Each exercise asked for defining a new class, setting up attributes with an `__init__` method, and writing one or more instance methods. While I understood the overall goals, I struggled with remembering the exact syntax and figuring out how to connect attributes and methods correctly. Because of that, I asked the AI for help on all 20 exercises.

After running the tests, I could see that the methods produced the expected results. This process helped me learn by example, even though I wasn’t always able to write the code independently. I now realize that I need more practice applying these ideas without step-by-step guidance so I can grow my confidence and problem-solving skills in Python.

Week 5:
AI Usage to brainstorm various function ideas for the function library. It helped me in seeing what has been done in class and what concepts seemed foreign to me and have not been taught in class. Trying to understand group member-created functions and to differentiate between complex and simple functions.  


Week 6:

I asked the AI to give me examples of how to create a class, define attributes, and write methods. It showed me step-by-step examples that I could run and test in my code editor. When I made mistakes, I used AI to explain the error messages and help me fix them. I also asked it to compare OOP to procedural programming, which helped me understand why OOP is more organized and reusable. What I liked most was that AI could adapt to my level of understanding. If something didn’t make sense, I could ask for a different explanation or a real-life analogy. 


Week 7: 
For our Project proposal, AI was used to help structure and organize our ideas into a clear and functional plan. Specifically, AI helped us outline the different levels of functions for our Function Library, from simple validation and formatting utilities to more complex operations like generating annual summaries and financial reports. This made it easier to understand how smaller, reusable helper functions could build up into larger, more advanced features for our budgeting system.

AI also helped suggest naming conventions, consistent parameter use, and realistic return types, which made the code easier to read and maintain. It provided examples of outputs and data structures

Week 8:

While doing Week 8 exercises, I was unsure about how responsibilities should be split between the parent LibraryMember class and its subclasses, and I found the instructions about when and how to override methods, especially max_concurrent_loans(). I also had difficulty understanding when to use super() correctly in constructors and how to choose which attributes belonged in the base class versus the child classes. I asked AI to explain these concepts, rephrase the assignment instructions, and help me understand common structural mistakes in object-oriented programming

Week 9: 

I am still struggling with comprehending how classes can work in Python, and abstract classes for this week's exercises required me to use Gemini to understand how abstract properties work. Learning how to add them was confusing. I also needed clarification on how abstract properties differ from regular properties, how to layer decorators like @property and @abstractmethod correctly, and how abstract class methods are supposed to be implemented in subclasses. Concepts like virtual subclass registration with LibraryItem.register(), implementing interfaces through Protocols, and writing template methods that depend on abstract hooks were also confusing at first.


Week 10: 

I had to come up with two classes to integrate into my group's Python project, where we are creating a budget app. I was confused about what kind of original classes I had to come up with two classes to integrate into my group’s Python project, where we are creating a budget app. I was confused about what kind of classes would make sense for our design, how much responsibility each class should have, and how they should interact with the existing classes, like Budget and Transaction.


Week 12: 
My group and I mainly used AI to help us understand the coding concepts behind the parts of our project we were refining from earlier work. When we were updating our classes like Category, Transaction, and Account, AI helped explain why certain design choices made sense and how different pieces of the code interacted. We used it to understand errors, clarify object-oriented programming ideas, and make sure our logic stayed consistent. Understanding and applying Python OOP concepts is very difficult even at this stage of the semester, considering how much thought and time is taken into understanding and trying to debug errors in our program. 



Week 13: 

My group used AI to finalize and help refine our final project. AI was used to help reason about how classes should interact, especially how accounts, categories, and different transaction types work together through shared interfaces. AI was also used to support decisions around keeping responsibilities separate, such as keeping balance calculations inside accounts and keeping transaction behavior inside the transaction classes. While developing and testing the system, AI helped the group think through consistency issues, such as how balances should be reconstructed from transaction history rather than stored directly.
